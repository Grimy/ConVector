/*
 * This file is part of DraWall.
 * DraWall is free software: you can redistribute it and/or modify it under the terms of the GNU
 * General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * DraWall is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details. You should have received a copy of the GNU
 * General Public License along with DraWall. If not, see <http://www.gnu.org/licenses/>.
 * © 2012–2014 Nathanaël Jourdane
 * © 2014-2015 Victor Adam
 */

package cc.drawall;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;

/** The base class for all Exporter plugins.
  * Provides a common template for all output filetypes. Abstract methods should be overriden
  * to implement the details relevant to a particular filetype. */
public abstract class Exporter {

	private static final Charset ASCII = Charset.forName("US-ASCII");
	protected static final String COMMENT = "generated by ConVector - http://convector.drawall.cc";

	protected final ByteBuffer empty = ByteBuffer.allocate(0);
	protected final ByteBuffer buffer = ByteBuffer.allocateDirect(64);
	protected int bytes;
	private final String[] format;
	double ratio;

	/** Constructs an exporter with the specified flags and segement formatting strings.
	  * @param flags a bit mask, constructed by OR-ing together the flags that apply.
	  * @param format a list of format strings for the different segment types:
	  * moveTo, lineTo, quadTo, curveTo and closePath. */
	protected Exporter(final String... format) {
		this.format = format;
	}

	/** A convenience method to write a formatted string to the output stream
	  * using the specified format string and arguments. */
	protected ByteBuffer format(final String format, final Object... args) {
		ByteBuffer result = ByteBuffer.wrap(String.format(format, args).getBytes(ASCII));
		bytes += result.limit();
		return result;
	}

	@SuppressWarnings("unused")
	protected ByteBuffer header(final double width, final double height, final double ratio) {
		return empty;
	}

	/** Writes the end of the output file.
	  * By default, this does nothing; subclasses should override this if the
	  * target filetype requires some form of footer. */
	protected ByteBuffer footer() {
		return empty;
	}

	/** Writes the necessary instructions to change the Color of the drawing.
	  * By default, this does nothing; subclasses should override this if the
	  * target filetype supports color.
	  * @param color the new painting color */
	@SuppressWarnings("unused")
	protected ByteBuffer color(final double red, final double green, final double blue) {
		return empty;
	}

	/** Writes a single segment to the output stream.
	  * By default, this formats the coordinates using one of the format strings
	  * passed to the constructor. */
	protected ByteBuffer segment(final int type, final double[] coords) {
		int i = 0;
		buffer.clear();
		for (final char chr: format[type].toCharArray()) {
			if (chr == '%') {
				buffer.put(Integer.toString((int) (coords[i++] / ratio)).getBytes(ASCII));
			} else {
				buffer.put((byte) chr);
			}
		}
		buffer.put((byte) '\n').flip();
		bytes += buffer.limit();
		return buffer;
	}
}
